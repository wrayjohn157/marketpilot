#!/usr/bin/env python3
"""
time_ticker_utils.py

A helper utility module for timestamp handling and ticker normalization.
All datetime objects are converted to UTC-aware datetimes.
"""

from datetime import datetime, timezone

def parse_timestamp(raw_value):
    """
    Parse a raw timestamp into a UTC-aware datetime.
    
    Accepts:
      - A UNIX timestamp (int or float). If > 1e10, assumed to be in milliseconds.
      - An ISO 8601 string (e.g. "2025-04-06T01:31:07Z").
      
    Returns a timezone-aware datetime in UTC.
    """
    if isinstance(raw_value, (int, float)):
        # If the value is large, assume milliseconds
        if raw_value > 1e10:
            dt = datetime.utcfromtimestamp(raw_value / 1000)
        else:
            dt = datetime.utcfromtimestamp(raw_value)
        return dt.replace(tzinfo=timezone.utc)
    elif isinstance(raw_value, str):
        try:
            # Replace "Z" with "+00:00" to make it ISO compliant
            dt = datetime.fromisoformat(raw_value.replace("Z", "+00:00"))
            if dt.tzinfo is None:
                dt = dt.replace(tzinfo=timezone.utc)
            return dt.astimezone(timezone.utc)
        except Exception as e:
            raise ValueError(f"Cannot parse timestamp string: {raw_value}") from e
    else:
        raise TypeError("Unsupported type for timestamp parsing. Must be int, float, or str.")

def to_iso(dt):
    """
    Convert a datetime object to an ISO 8601 string with 'Z' suffix.
    """
    if dt.tzinfo is None:
        dt = dt.replace(tzinfo=timezone.utc)
    else:
        dt = dt.astimezone(timezone.utc)
    return dt.isoformat().replace("+00:00", "Z")

def normalize_ticker(ticker):
    """
    Normalize ticker symbols to a consistent format.
    
    For example:
      - "USDT_ABC" becomes "ABCUSDT"
      - "ABC_USDT" becomes "ABCUSDT"
      - If ticker already ends with "USDT", it is returned unchanged.
    """
    if "_" in ticker:
        parts = ticker.split("_")
        # If format is "USDT_XXX", return "XXXUSDT"
        if parts[0].upper() == "USDT":
            return parts[1].upper() + "USDT"
        # If format is "XXX_USDT", remove the underscore
        elif parts[-1].upper() == "USDT":
            return "".join(parts).upper()
    return ticker.upper()

def closest_timestamp(target, timestamps):
    """
    Given a target datetime and a list of datetime objects,
    return the datetime from the list that is closest to the target.
    """
    if not timestamps:
        return None
    return min(timestamps, key=lambda dt: abs(dt - target))

# --- Simple tests (run when executed directly) ---
if __name__ == "__main__":
    # Test timestamp parsing
    raw_ts1 = 1743903067  # UNIX seconds
    raw_ts2 = 1743903067000  # UNIX ms
    raw_ts3 = "2025-04-06T01:31:07Z"
    dt1 = parse_timestamp(raw_ts1)
    dt2 = parse_timestamp(raw_ts2)
    dt3 = parse_timestamp(raw_ts3)
    print("Parsed timestamps:")
    print("dt1:", dt1, "->", to_iso(dt1))
    print("dt2:", dt2, "->", to_iso(dt2))
    print("dt3:", dt3, "->", to_iso(dt3))
    
    # Test ticker normalization
    print("Normalized tickers:")
    print("USDT_DOGE ->", normalize_ticker("USDT_DOGE"))
    print("DOGE_USDT ->", normalize_ticker("DOGE_USDT"))
    print("DOGE ->", normalize_ticker("DOGE"))
