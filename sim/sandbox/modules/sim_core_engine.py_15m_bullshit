import sys
from pathlib import Path

# allow imports of sandbox modules and top-level packages
file = Path(__file__).resolve()
sandbox_dir = file.parents[1]  # .../sim/sandbox
project_root = file.parents[3]  # .../market7
sys.path.insert(0, str(sandbox_dir))
sys.path.insert(0, str(project_root))

import yaml
import json
from pathlib import Path
from config.config_loader import PATHS
from dca.utils.btc_filter import get_btc_status
from sim.sandbox.utils.local_indicators import (
    fetch_binance_klines,
    compute_all_indicators,
)
from sim.sandbox.utils.sandbox_kline_utils import load_klines_around_time
import pandas as pd

from sim.sandbox.utils.kline_loader_cross_day import load_forward_klines_cross_days

from dca.utils.entry_utils import get_latest_indicators, get_rsi_slope, get_macd_lift
from dca.modules.dca_decision_engine import should_dca
from dca.utils.spend_predictor import adjust_volume
from dca.utils.recovery_confidence_utils import predict_confidence_score
from dca.utils.zombie_utils import is_zombie_trade
from dca.utils.spend_predictor import predict_spend_volume
from dca.modules.fork_safu_evaluator import (
    get_safu_exit_decision,
    load_safu_exit_model,
    get_safu_score,
)

print("[DEBUG] âœ… core.py simulation triggered")


def compute_indicators(symbol: str, tf: str = "15m", entry_time: int = None) -> dict:
    if entry_time:
        df = load_klines_around_time(
            symbol, tf=tf, center_time=entry_time, lookback_candles=100
        )
    else:
        df = fetch_binance_klines(symbol, interval=tf, limit=100)

    if isinstance(df, list):
        df = pd.DataFrame(df)
    if df is None or df.empty:
        return {}

    from ta.momentum import RSIIndicator
    from ta.trend import MACD

    close = df["close"]
    rsi = RSIIndicator(close=close).rsi().iloc[-1]
    macd = MACD(close=close)
    macd_hist = macd.macd_diff().iloc[-1]
    macd_hist_prev = macd.macd_diff().iloc[-2]
    macd_lift = macd.macd().iloc[-1] - macd.macd().iloc[-2]

    return {
        "rsi": rsi,
        "macd_histogram": macd_hist,
        "macd_histogram_prev": macd_hist_prev,
        "macd_lift": macd_lift,
    }


def load_config(path: Path = None, fallback: bool = False):
    """
    Load a DCA configuration YAML from the given path or default production path.

    If fallback is True, load the fallback default config instead.
    """
    if fallback:
        config_path = Path(
            "/home/signal/market7/sim/config/sim_dca_config_fallback.yaml"
        )
    elif path:
        config_path = Path(path)
    else:
        config_path = PATHS["dca_config"]
    with open(config_path) as f:
        return yaml.safe_load(f)


def simulate_dca_step(trade, config):
    symbol = trade.get("symbol")
    tf = config.get("timeframe", "15m")
    entry_time = trade.get("entry_time")
    indicators = compute_indicators(symbol, tf, entry_time)

    from dca.utils.entry_utils import (
        load_btc_market_condition,
        load_fork_entry_score,
        load_entry_score_from_redis,
    )
    from dca.utils.recovery_odds_utils import (
        get_latest_snapshot,
        predict_recovery_odds,
    )

    deal_id = trade.get("deal_id")
    timestamp = trade.get("timestamp")

    btc_status = get_btc_status(config.get("btc_indicators", {}))
    entry_score = load_fork_entry_score(symbol, timestamp)
    current_score = load_entry_score_from_redis(deal_id)
    safu_score = 0.8  # TODO: replace with real get_safu_score(symbol, tf) if available
    tp1_sim_pct = 14.5  # TODO: replace with simulate_tp1_shift(trade) if available

    snapshot = get_latest_snapshot(symbol, deal_id)
    recovery_odds = predict_recovery_odds(snapshot)

    confidence_score = predict_confidence_score(
        {
            "deal_id": deal_id,
            "symbol": symbol,
            "entry_score": entry_score,
            "current_score": current_score,
            "tp1_shift": tp1_sim_pct,
            "safu_score": safu_score,
            "rsi": indicators.get("rsi", 0.0),
            "macd_histogram": indicators.get("macd_histogram", 0.0),
            "adx": indicators.get("adx", 0.0),
            "macd_lift": indicators.get("macd_lift", 0.0),
            "rsi_slope": indicators.get("rsi_slope", 0.0),
            "drawdown_pct": trade.get("drawdown_pct", 0.0),
        }
    )

    from dca.utils.safu_reentry_utils import should_reenter_after_safu

    zombie = is_zombie_trade(indicators, recovery_odds, current_score)

    from dca.utils.trade_health_evaluator import evaluate_trade_health

    trade_features = {
        "recovery_odds": recovery_odds,
        "confidence_score": confidence_score,
        "safu_score": safu_score,
        "entry_score": entry_score or 0,
        "current_score": current_score or 0,
        "rsi": indicators.get("rsi", 50),
        "macd_histogram": indicators.get("macd_histogram", 0),
        "adx": indicators.get("adx", 20),
    }

    health = evaluate_trade_health(trade_features)
    health_score = health["health_score"]
    health_status = health["health_status"]

    if entry_time:
        btc_df = load_klines_around_time(
            "BTCUSDT", tf="1h", center_time=entry_time, lookback_candles=251
        )
    else:
        btc_df = fetch_binance_klines("BTCUSDT", interval="1h", limit=251)

    # ðŸ©¹ Fix unnamed columns if needed
    if isinstance(btc_df, pd.DataFrame) and 0 in btc_df.columns:
        btc_df.columns = [
            "timestamp", "open", "high", "low", "close", "volume",
            "close_time", "quote_asset_volume", "num_trades",
            "taker_buy_base", "taker_buy_quote", "ignore"
        ]

    btc_indicators = compute_all_indicators(btc_df) if btc_df is not None else {}
    btc_rsi = btc_indicators.get("RSI14", 0.0)
    btc_macd_histogram = btc_indicators.get("MACD_Histogram", 0.0)
    btc_adx = btc_indicators.get("ADX14", 0.0)

    spend_features = {
        "entry_score": entry_score,
        "current_score": current_score,
        "drawdown_pct": trade.get("drawdown_pct", 0.0),
        "safu_score": safu_score,
        "macd_lift": indicators.get("macd_lift", 0.0),
        "rsi": indicators.get("rsi", 0.0),
        "rsi_slope": indicators.get("rsi_slope", 0.0),
        "adx": indicators.get("adx", 0.0),
        "tp1_shift": tp1_sim_pct,
        "recovery_odds": recovery_odds,
        "confidence_score": confidence_score,
        "zombie_tagged": int(zombie),
        "btc_rsi": btc_rsi,
        "btc_macd_histogram": btc_macd_histogram,
        "btc_adx": btc_adx,
        "btc_status": btc_status,
    }
    # ðŸ©¹ Ensure all values are numeric for model input
    spend_features = {k: pd.to_numeric(v, errors="coerce") for k, v in spend_features.items()}

    predicted_spend_volume = predict_spend_volume(spend_features)

    last_safu_time = None  # TODO: Load actual last SAFU timestamp if available
    reentry_allowed = should_reenter_after_safu(
        trade=trade,
        config=config,
        indicators=indicators,
        safu_score=safu_score,
        tp1_shift_pct=tp1_sim_pct,
        last_safu_time=last_safu_time,
        btc_status=btc_status,
    )

    fire, reason, odds = should_dca(
        trade=trade,
        config=config,
        indicators=indicators,
        btc_status=btc_status,
        entry_score=entry_score,
        current_score=current_score,
        safu_score=safu_score,
        tp1_sim_pct=tp1_sim_pct,
        recovery_odds=recovery_odds,
    )

    if fire:
        volume = adjust_volume(trade, config, indicators)
        return {
            "timestamp": trade.get("timestamp"),
            "symbol": symbol,
            "volume": volume,
            "reason": reason,
            "confidence_score": confidence_score,
            "zombie": zombie,
            "health_score": health_score,
            "health_status": health_status,
            "predicted_spend_volume": predicted_spend_volume,
            "reentry_allowed": reentry_allowed,
        }
    else:
        return {
            "timestamp": trade.get("timestamp"),
            "symbol": symbol,
            "volume": 0.0,
            "reason": reason,
            "confidence_score": confidence_score,
            "zombie": zombie,
            "health_score": health_score,
            "health_status": health_status,
            "predicted_spend_volume": predicted_spend_volume,
            "reentry_allowed": reentry_allowed,
        }


# --- Added function for running DCA simulation ---
def run_dca_simulation(
    symbol: str, entry_time: int, tf: str = "1h", config_path: str = None
):
    from sim.sandbox.utils.trade_utils import build_mock_trade

    # --- Ensure entry_time is an int ---
    entry_time = int(entry_time)

    config = load_config(path=Path(config_path)) if config_path else load_config()
    base_trade = build_mock_trade(symbol=symbol, entry_time=entry_time, tf=tf)
    if not base_trade:
        return {"error": "Failed to build trade input."}

    # --- Load all klines needed and debug print for timestamp search ---
    klines = load_forward_klines_cross_days(symbol, tf, start_time=entry_time)
    print(f"[debug] Entry time: {entry_time}")
    # Debug: handle dict or list kline formats
    first_ts = [int(k["timestamp"]) if isinstance(k, dict) else int(k[0]) for k in klines[:5]]
    print(f"[debug] First few kline timestamps: {first_ts}")
    last = klines[-1]
    last_ts = int(last["timestamp"]) if isinstance(last, dict) else int(last[0])
    print(f"[debug] Last kline timestamp: {last_ts}")

    results = []
    for idx, kline in enumerate(klines):
        try:
            # kline may be list or dict; handle both
            if isinstance(kline, dict):
                ts = int(kline["timestamp"]) if isinstance(kline["timestamp"], int) else int(pd.to_datetime(kline["timestamp"]).timestamp() * 1000)
                close = kline["close"]
            else:
                ts = int(kline[0])
                close = kline[4]
        except Exception as e:
            print(f"[ERROR] Failed to parse timestamp for kline {idx}: {e}")
            continue
        trade = base_trade.copy()
        trade["timestamp"] = ts
        trade["drawdown_pct"] = 100 * (close - trade["entry_price"]) / trade["entry_price"]
        result = simulate_dca_step(trade, config)
        results.append(result)
        print(json.dumps(result, indent=2))  # Optional: import json at the top if not already

    print(f"[âœ…] Simulation complete â€” evaluated {len(results)} DCA bars from entry_time.")
    return results
