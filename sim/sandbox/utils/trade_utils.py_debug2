from .sandbox_kline_utils import load_klines_around_time


def load_price_at_entry(symbol: str, entry_time: int, tf: str = "1h") -> float:
    print(f"ğŸ” Loading klines for {symbol} at {entry_time} ({tf})")
    klines = load_klines_around_time(symbol, tf, entry_time)
    if klines is None:
        print("âŒ Klines returned None.")
        return None
    if len(klines) == 0:
        print("âŒ Klines list is empty.")
        return None
    print(f"âœ… Loaded {len(klines)} klines")

    valid = [k for k in klines if isinstance(k, dict) and k.get("timestamp", 0) <= entry_time]
    if not valid:
        # fallback: try to find the nearest earlier kline by sorting
        sorted_klines = sorted([k for k in klines if isinstance(k, dict)], key=lambda x: x["timestamp"])
        for k in reversed(sorted_klines):
            if k["timestamp"] <= entry_time:
                print(f"ğŸŸ¡ Fallback matched kline at {k['timestamp']}")
                return k["close"]
        print(f"ğŸ›  Fallback failed. Kline timestamps seen: {[k['timestamp'] for k in sorted_klines]}")
        return None
    print(f"ğŸŸ¢ Found valid kline at or before entry_time: {valid[-1]}")
    return valid[-1]["close"]


def build_mock_trade(symbol: str, entry_time: int, tf: str = "1h") -> dict:
    price = load_price_at_entry(symbol, entry_time, tf)
    if price is None:
        return {}
    return {
        "symbol": symbol,
        "entry_time": entry_time,
        "timestamp": entry_time,
        "deal_id": f"sim-{symbol}-{entry_time}",
        "drawdown_pct": 4.5,  # Optional
        "avg_entry_price": price,
    }
