
from .sandbox_kline_utils import load_klines_around_time


# Helper to normalize timestamps to int milliseconds
def _to_int_timestamp(ts):
    if isinstance(ts, (int, float, str)):
        return int(float(ts))
    elif hasattr(ts, "timestamp"):  # Handles pandas.Timestamp or datetime
        return int(ts.timestamp() * 1000)
    return 0


def load_price_at_entry(symbol: str, entry_time: int, tf: str = "1h") -> float:
    print(f"ğŸ” Loading klines for {symbol} at {entry_time} ({tf})")
    klines = load_klines_around_time(symbol, tf, entry_time)
    if klines is None:
        print("âŒ Klines returned None.")
        return None
    if len(klines) == 0:
        print("âŒ Klines list is empty.")
        return None
    print(f"âœ… Loaded {len(klines)} klines")

    valid = [k for k in klines if isinstance(k, dict) and _to_int_timestamp(k.get("timestamp")) <= entry_time]
    if not valid:
        # fallback: try to find the nearest earlier kline by sorting
        sorted_klines = sorted([k for k in klines if isinstance(k, dict)], key=lambda x: _to_int_timestamp(x["timestamp"]))
        for k in reversed(sorted_klines):
            if _to_int_timestamp(k["timestamp"]) <= entry_time:
                print(f"ğŸŸ¡ Fallback matched kline at {k['timestamp']}")
                return k["close"]
        print(f"ğŸ›  Fallback failed. Kline timestamps seen: [{[_to_int_timestamp(k['timestamp']) for k in sorted_klines]}]")
        return None
    print(f"ğŸŸ¢ Found valid kline at or before entry_time: {valid[-1]}")
    return valid[-1]["close"]


def build_mock_trade(symbol: str, entry_time: int, tf: str = "1h") -> dict:
    price = load_price_at_entry(symbol, entry_time, tf)
    if price is None: 
        return {}
    return {
        "symbol": symbol,
        "entry_time": entry_time,
        "timestamp": entry_time,
        "deal_id": f"sim-{symbol}-{entry_time}",
        "drawdown_pct": 4.5,  # Optional
        "avg_entry_price": price,
    }
