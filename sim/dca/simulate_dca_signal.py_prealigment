# === DCA SIMULATION SCRIPT ===
# This script simulates smart DCA decisions using saved snapshots and tunable config
# Does not interfere with live trade logic or affect 3Commas activity

import sys
from pathlib import Path

BASE_DIR = Path(__file__).resolve().parent.parent.parent
sys.path.append(str(BASE_DIR))

import argparse
from datetime import timezone


def simulate_dca_forward(entry_timestamp, symbol, strategy_config_name, tf="5m"):
    """
    Simulate DCA logic forward in time using indicator snapshots and strategy config.
    Args:
        entry_timestamp (int): Unix ms timestamp to start from.
        symbol (str): 3c symbol, e.g., USDT_BTC.
        strategy_config_name (str): Name or path to strategy config YAML.
        tf (str): Timeframe to use for simulation (e.g., "5m", "15m", "1h"). This parameter allows you to select the timeframe; if not provided, falls back to config or "5m".
    Returns:
        List of dicts, each describing a simulated DCA step trigger and logic.
    """
    import glob
    import bisect
    from datetime import datetime, timedelta
    from pathlib import Path
    import json

    # Determine entry_dt from ms timestamp
    from datetime import datetime
    entry_dt = datetime.utcfromtimestamp(entry_timestamp / 1000)

    # Then convert to seconds if necessary for snapshot indexing
    if entry_timestamp > 1e12:
        entry_timestamp = int(entry_timestamp / 1000)

    # --- Load strategy config ---
    # Use sim.config.sim_config_loader to load config
    from sim.config.sim_config_loader import load_sim_config

    strategy_config = load_sim_config(strategy_config_name)

    # --- Determine timeframes from config ---
    tf = strategy_config.get("timeframe", tf)
    # Accept symbol as USDT_BTC or BTC, try both
    sym_base = symbol.replace("USDT_", "")
    # Find snapshot file for the symbol and tf, using entry_timestamp's date
    date_str = entry_dt.strftime("%Y-%m-%d")
    snapshot_dir = BASE_DIR / "data" / "snapshots" / date_str
    # Try both {symbol}_{tf}.jsonl and {sym_base}_{tf}.jsonl
    candidates = [
        snapshot_dir / f"{symbol}_{tf}.jsonl",
        snapshot_dir / f"{sym_base}_{tf}.jsonl",
    ]
    snapshot_path = None
    for c in candidates:
        if c.exists():
            snapshot_path = c
            break
    # --- Logging for snapshot path and timestamp ---
    import logging
    from datetime import datetime

    logger = logging.getLogger("simulate_dca_forward")
    logger.info(f"Looking for snapshot file at: {snapshot_path}")
    logger.info(f"ENTRY TIMESTAMP (ms): {entry_timestamp}")
    logger.info(
        f"Resolved date: {datetime.utcfromtimestamp(entry_timestamp / 1000).date()}"
    )
    print(f"üîç Looking for snapshot: {snapshot_path}")
    if not snapshot_path:
        raise FileNotFoundError(
            f"No snapshot file found for {symbol} on {date_str} at tf={tf}"
        )

    # --- Load snapshots ---

    with open(snapshot_path, "r") as f:
        lines = [json.loads(line) for line in f]

    matching = [r for r in lines if int(r["timestamp"]) <= entry_timestamp]
    if not matching:
        from fastapi import HTTPException

        raise HTTPException(
            status_code=404, detail=f"No snapshot found before or at {entry_timestamp}"
        )
    snapshot = max(matching, key=lambda x: x["timestamp"])

    # --- Continue simulation from snapshot ---
    # We will find the index of the snapshot in the full list to simulate forward
    # Parse all snapshots with timestamps in ms for sorting and simulation
    snapshots = []
    for d in lines:
        ts = None
        if "timestamp" in d:
            v = d["timestamp"]
            if isinstance(v, (int, float)):
                ts = int(v)
                if ts < 1_000_000_000_000:  # Convert seconds to milliseconds if needed
                    ts = ts * 1000
            else:
                try:
                    ts = int(
                        datetime.fromisoformat(v.replace("Z", "+00:00")).timestamp()
                        * 1000
                    )
                except Exception:
                    ts = None
        d["_ts"] = ts
        snapshots.append(d)

    # Sort snapshots by timestamp
    snapshots = [s for s in snapshots if s.get("_ts") is not None]
    snapshots.sort(key=lambda x: x["_ts"])

    # Find index of snapshot in snapshots list
    idx = None
    for i, s in enumerate(snapshots):
        ts_sec = (
            int(s["timestamp"]) if isinstance(s["timestamp"], (int, float)) else None
        )
        if ts_sec is None:
            continue
        # Convert to seconds if timestamp in ms
        # (No need to check > 1e12 here for entry_timestamp again)
        if ts_sec > 1e12:
            ts_sec = int(ts_sec / 1000)
        if ts_sec == int(snapshot["timestamp"]):
            idx = i
            break

    if idx is None:
        raise ValueError(
            f"Snapshot found but index not found in snapshots list for timestamp {snapshot['timestamp']}"
        )

    # --- Simulate DCA logic forward ---
    results = []
    last_fired_step = 0
    entry_score = None
    reason = ""
    so_table = strategy_config.get("so_volume_table", [10, 20, 30, 50, 80, 120])
    trigger_pct = strategy_config.get("drawdown_trigger_pct", 1.5)
    step_repeat_guard = strategy_config.get("step_repeat_guard", {})
    progress_guard = strategy_config.get("step_progress_guard", {})
    override_conf = strategy_config.get("confidence_dca_guard", {})
    soft_conf_override = strategy_config.get("soft_confidence_override", {})
    use_confidence_override = strategy_config.get("use_confidence_override", True)
    use_soft_confidence_override = strategy_config.get(
        "use_soft_confidence_override", True
    )
    min_confidence_odds = strategy_config.get("min_confidence_odds", 0.65)
    max_trade_usdt = strategy_config.get("max_trade_usdt", 2000)

    last_conf_score = 0.0
    last_tp1_shift = 0.0
    last_logged = None
    prev_price = 0.0
    prev_time = None
    prev_be = 0.0

    # For simulation, we must track: step, last_conf_score, last_tp1_shift, etc.
    for i in range(idx, len(snapshots)):
        snap = snapshots[i]
        # Extract indicators
        indicators = {
            k: v
            for k, v in snap.items()
            if k not in ("timestamp", "_ts", "symbol", "deal_id")
        }
        current_price = snap.get("current_price") or indicators.get("current_price")
        avg_entry_price = snap.get("avg_entry_price") or indicators.get(
            "avg_entry_price"
        )
        if avg_entry_price is None or avg_entry_price == 0:
            continue
        deviation_pct = (
            ((avg_entry_price - current_price) / avg_entry_price) * 100
            if avg_entry_price
            else 0.0
        )
        safu_score = indicators.get("safu_score", 1.0)
        entry_score = snap.get("entry_score", entry_score)
        current_score = snap.get("current_score", None)
        tp1_shift = snap.get("tp1_shift", 0.0)
        be_improvement = snap.get("be_improvement", 0.0)
        recovery_odds = snap.get("recovery_odds", 0.0)
        confidence_score = snap.get("confidence_score", 0.0)
        btc_status = snap.get("btc_status", "SAFE")
        macd_lift = indicators.get("macd_lift", 0.0)
        rsi_slope = indicators.get("rsi_slope", 0.0)
        health_score = snap.get("health_score", 1.0)
        health_status = snap.get("health_status", "Healthy")
        zombie_tagged = snap.get("zombie_tagged", False)

        # Step logic
        conf_delta = confidence_score - last_conf_score
        tp1_gain = tp1_shift - last_tp1_shift
        step = last_fired_step + 1
        ladder_amount = so_table[step] if step < len(so_table) else so_table[-1]
        # --- Step Repeat Guard ---
        same_step = last_logged and last_logged.get("step", 0) == last_fired_step
        prev_conf = last_logged.get("confidence_score", 0.0) if last_logged else 0.0
        prev_tp1 = last_logged.get("tp1_shift", 0.0) if last_logged else 0.0
        conf_improved = (confidence_score - prev_conf) > step_repeat_guard.get(
            "min_conf_delta", 0.02
        )
        tp1_improved = (tp1_shift - prev_tp1) > step_repeat_guard.get(
            "min_tp1_delta", 0.25
        )
        if (
            last_logged
            and step_repeat_guard.get("enabled", True)
            and same_step
            and not (conf_improved or tp1_improved)
        ):
            reason = "no_step_improvement"
            results.append(
                {
                    "timestamp": snap["timestamp"],
                    "step": step,
                    "decision": "skipped",
                    "rejection_reason": reason,
                    "confidence_score": confidence_score,
                    "tp1_shift": tp1_shift,
                    "drawdown_pct": deviation_pct,
                    "logic": "Step repeat guard: no significant improvement",
                }
            )
            continue
        # --- Step Progression Guard ---
        price_change_pct = (
            (abs(current_price - prev_price) / prev_price * 100) if prev_price else 0
        )
        time_elapsed = ((snap["_ts"] - prev_time) / 1000) if prev_time else 999999
        be_gain = be_improvement - prev_be
        if (
            last_logged
            and progress_guard.get("enabled", True)
            and price_change_pct < progress_guard.get("min_price_change_pct", 0.3)
            and time_elapsed < progress_guard.get("min_seconds_elapsed", 600)
            and be_gain < progress_guard.get("min_be_improvement_pct", 0.5)
        ):
            reason = "step_progress_insufficient"
            results.append(
                {
                    "timestamp": snap["timestamp"],
                    "step": step,
                    "decision": "skipped",
                    "rejection_reason": reason,
                    "confidence_score": confidence_score,
                    "tp1_shift": tp1_shift,
                    "drawdown_pct": deviation_pct,
                    "logic": "Step progression guard: insufficient price/time/be change",
                }
            )
            continue
        # --- Main DCA logic (should_dca) ---
        from sim.dca.utils.sim_dca_logic import simulate_dca_decision

        should_fire, dca_reason, _ = simulate_dca_decision(
            trade={
                "pair": symbol,
                "current_price": current_price,
                "average_buy_price": avg_entry_price,
            },
            config=strategy_config,
            indicators=indicators,
            btc_status=btc_status,
            entry_score=entry_score,
            current_score=current_score,
            safu_score=safu_score,
            tp1_sim_pct=tp1_shift,
            recovery_odds=recovery_odds,
        )
        # --- Confidence override ---
        if (
            use_confidence_override
            and not should_fire
            and confidence_score >= min_confidence_odds
            and conf_delta >= override_conf.get("min_confidence_delta", 0.05)
            and tp1_gain >= override_conf.get("min_tp1_shift_gain_pct", 0.25)
            and deviation_pct >= trigger_pct
            and safu_score >= override_conf.get("safu_score_min", 0.5)
            and macd_lift >= override_conf.get("macd_lift_min", 0.00005)
            and rsi_slope >= override_conf.get("rsi_slope_min", 1.0)
        ):
            should_fire = True
            dca_reason = "confidence_override"
        # --- Soft confidence override ---
        if (
            use_soft_confidence_override
            and not should_fire
            and confidence_score >= soft_conf_override.get("min_confidence", 0.75)
            and recovery_odds >= soft_conf_override.get("min_recovery_odds", 0.8)
            and safu_score >= soft_conf_override.get("min_safu_score", 0.7)
            and health_score >= soft_conf_override.get("min_health_score", 0.6)
            and deviation_pct >= soft_conf_override.get("min_drawdown_pct", 2.0)
            and conf_delta >= soft_conf_override.get("min_confidence_delta", 0.05)
            and tp1_shift >= soft_conf_override.get("min_tp1_shift_pct", 2.0)
        ):
            should_fire = True
            dca_reason = "smart_soft_rescue"
        # --- Record result ---
        logic_explanation = {
            "should_dca": should_fire,
            "reason": dca_reason,
            "confidence_score": confidence_score,
            "tp1_shift": tp1_shift,
            "drawdown_pct": deviation_pct,
            "safu_score": safu_score,
            "recovery_odds": recovery_odds,
            "health_score": health_score,
            "macd_lift": macd_lift,
            "rsi_slope": rsi_slope,
        }
        if should_fire:
            results.append(
                {
                    "timestamp": snap["timestamp"],
                    "step": step,
                    "decision": "would_fire",
                    "logic": logic_explanation,
                }
            )
            # Update simulation state
            last_fired_step = step
            last_conf_score = confidence_score
            last_tp1_shift = tp1_shift
            last_logged = {
                "step": step,
                "confidence_score": confidence_score,
                "tp1_shift": tp1_shift,
                "current_price": current_price,
                "timestamp": snap["timestamp"],
                "be_improvement": be_improvement,
            }
            prev_price = current_price
            prev_time = snap["_ts"]
            prev_be = be_improvement
        else:
            results.append(
                {
                    "timestamp": snap["timestamp"],
                    "step": step,
                    "decision": "skipped",
                    "rejection_reason": dca_reason,
                    "logic": logic_explanation,
                }
            )
    return results


# --- CLI entry point for simulation ---
if __name__ == "__main__":
    import sys
    import json

    parser = argparse.ArgumentParser(description="Smart DCA Signal")
    parser.add_argument(
        "--simulate", action="store_true", help="Run DCA simulation forward"
    )
    parser.add_argument(
        "--entry_timestamp", type=int, help="Entry timestamp (ms since epoch)"
    )
    parser.add_argument("--symbol", type=str, help="Symbol, e.g., USDT_BTC")
    parser.add_argument(
        "--strategy_config", type=str, help="Path to strategy config YAML"
    )
    parser.add_argument(
        "--tf", type=str, default="5m", help="Timeframe (e.g., 5m, 15m, 1h)"
    )
    args = parser.parse_args()
    if args.simulate:
        if not (args.entry_timestamp and args.symbol and args.strategy_config):
            print(
                "Must provide --entry_timestamp, --symbol, and --strategy_config for simulation."
            )
            sys.exit(1)
        results = simulate_dca_forward(
            args.entry_timestamp, args.symbol, args.strategy_config, tf=args.tf
        )
        print(json.dumps(results, indent=2, default=str))
    else:
        # For live run, import from sim namespace
        from sim.dca.signal_live import run

        run()
