import json
import time
import hmac
import hashlib
import requests
from datetime import datetime
from pathlib import Path

# Paths
CANDIDATE_PATH = Path("/home/signal/market6/output/final_fork_rrr_trades.json")
SNAPSHOT_BASE = Path("/home/signal/market6/data/snapshots")
RESULTS_BASE = Path("/home/signal/market6/live/logs")
REGISTRY_PATH = RESULTS_BASE / "fork_registry.json"
CRED_PATH = Path("/home/signal/market6/config/paper_cred.json")

# Constants
DEDUP_EXPIRY_SECONDS = 3600 * 6  # 6 hours

def compute_score_hash(indicators):
    keys = ["macd_histogram", "stoch_rsi_cross", "rsi_recovery", "adx_rising", "ema_price_reclaim"]
    return "_".join([f"{k}:{indicators.get(k, 0)}" for k in keys])

def get_day_folder(entry_time):
    day = datetime.utcfromtimestamp(entry_time).strftime("%Y-%m-%d")
    folder = RESULTS_BASE / day
    folder.mkdir(parents=True, exist_ok=True)
    return folder

def get_entry_price(symbol, entry_ts):
    date_str = datetime.utcfromtimestamp(entry_ts).strftime("%Y-%m-%d")
    base = symbol.replace("USDT", "") if symbol.endswith("USDT") else symbol
    filename = f"{base}_15m_klines.json"
    filepath = SNAPSHOT_BASE / date_str / filename

    if not filepath.exists():
        print(f"[WARN] Snapshot not found: {filepath}")
        return None

    with open(filepath, "r") as f:
        klines = json.load(f)

    fallback_price = None
    for kline in klines:
        candle_ts = kline[0] // 1000
        if candle_ts <= entry_ts:
            fallback_price = float(kline[4])
        else:
            break

    return fallback_price

def save_daily_entry(entry):
    folder = get_day_folder(entry["entry_time"])
    out_path = folder / "completed_forks.jsonl"
    with open(out_path, "a") as f:
        f.write(json.dumps(entry) + "\n")

def load_registry():
    if REGISTRY_PATH.exists():
        with open(REGISTRY_PATH, "r") as f:
            return json.load(f)
    return {}

def save_registry(registry):
    with open(REGISTRY_PATH, "w") as f:
        json.dump(registry, f, indent=2)

def get_live_3c_symbols():
    with open(CRED_PATH, "r") as f:
        creds = json.load(f)

    BOT_ID = creds["3commas_bot_id"]
    API_KEY = creds["3commas_api_key"]
    API_SECRET = creds["3commas_api_secret"]
    full_path = "/public/api/ver1/deals?scope=active"
    url = "https://api.3commas.io" + full_path
    signature = hmac.new(API_SECRET.encode(), full_path.encode(), hashlib.sha256).hexdigest()

    headers = {
        "Apikey": API_KEY,
        "Signature": signature
    }

    try:
        res = requests.get(url, headers=headers, timeout=10)
        res.raise_for_status()
        deals = res.json()

        symbols = set()
        for d in deals:
            if d.get("bot_id") == BOT_ID and d.get("status") == "bought":
                pair = d.get("pair", "")
                if pair.startswith("USDT_"):
                    symbols.add(pair.split("_")[1] + "USDT")
        return symbols

    except Exception as e:
        print(f"[ERROR] Failed to pull 3Commas trades: {e}")
        return set()

def get_live_3c_trades():
    with open(CRED_PATH, "r") as f:
        creds = json.load(f)

    BOT_ID = creds["3commas_bot_id"]
    API_KEY = creds["3commas_api_key"]
    API_SECRET = creds["3commas_api_secret"]
    path = "/public/api/ver1/deals?scope=active"
    url = "https://api.3commas.io" + path
    signature = hmac.new(API_SECRET.encode(), path.encode(), hashlib.sha256).hexdigest()

    headers = {
        "Apikey": API_KEY,
        "Signature": signature
    }

    try:
        res = requests.get(url, headers=headers, timeout=10)
        res.raise_for_status()
        return [d for d in res.json() if d.get("bot_id") == BOT_ID]
    except Exception as e:
        print(f"[ERROR] Failed to fetch 3Commas trades: {e}")
        return []

def send_dca_signal(symbol):
    with open(CRED_PATH, "r") as f:
        creds = json.load(f)

    payload = {
        "bot_id": creds["3commas_bot_id"],
        "email_token": creds.get("3commas_email_token"),
        "pair": symbol,
        "skip_signal_check": True
    }

    query = "/public/api/ver1/bots/send_signal"
    url = "https://api.3commas.io" + query
    signature = hmac.new(creds["3commas_api_secret"].encode(), query.encode(), hashlib.sha256).hexdigest()
    headers = {
        "APIKEY": creds["3commas_api_key"],
        "Signature": signature,
        "Content-Type": "application/json"
    }

    try:
        res = requests.post(url, headers=headers, data=json.dumps(payload))
        res.raise_for_status()
        print(f"âœ… DCA signal sent for {symbol}")
    except Exception as e:
        print(f"[ERROR] Failed to send DCA signal for {symbol}: {e}")

def get_latest_indicators(symbol, tf="15m"):
    # Parse the latest snapshot candle for basic indicators
    path = SNAPSHOT_BASE / datetime.utcnow().strftime("%Y-%m-%d") / f"{symbol}_{tf}_klines.json"
    if not path.exists():
        print(f"[WARN] Missing snapshot for {symbol}")
        return {}

    try:
        with open(path) as f:
            data = json.load(f)
        if len(data) < 2:
            return {}

        latest = data[-1]
        return {
            "rsi": float(latest[7]),
            "macd_histogram": float(latest[17]),
            "adx": float(latest[8])
        }
    except Exception as e:
        print(f"[ERROR] Could not parse snapshot for {symbol}: {e}")
        return {}
