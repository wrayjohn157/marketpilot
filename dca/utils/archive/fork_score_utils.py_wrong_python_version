#!/usr/bin/env python3

import json
from datetime import datetime
from pathlib import Path
from indicators.fork_score_filter import compute_subscores

# === Paths ===
FORK_HISTORY_BASE = Path("/home/signal/market6/output/fork_history")

# === Entry Score Loader ===
def load_fork_entry_score(symbol: str, entry_ts: int) -> float | None:
    """Return fork score closest to entry timestamp from fork history."""
    date_str = datetime.utcfromtimestamp(entry_ts / 1000).strftime("%Y-%m-%d")
    path = FORK_HISTORY_BASE / date_str / "fork_scores.jsonl"
    if not path.exists():
        return None

    best_match = None
    best_diff = float("inf")

    with open(path, "r") as f:
        for line in f:
            try:
                obj = json.loads(line)
                if obj.get("symbol") != symbol:
                    continue
                ts = int(obj.get("timestamp", 0))
                diff = abs(ts - entry_ts)
                if diff < best_diff and diff < 300_000:
                    best_match = obj
                    best_diff = diff
            except Exception:
                continue

    return best_match.get("score") if best_match else None

# === Recent Score Loader (use this before fallback) ===
def load_recent_score(symbol: str, now_ts: int) -> float | None:
    """Return the most recent fork score within 10min of now."""
    date_str = datetime.utcfromtimestamp(now_ts / 1000).strftime("%Y-%m-%d")
    path = FORK_HISTORY_BASE / date_str / "fork_scores.jsonl"
    if not path.exists():
        return None

    best = None
    best_diff = float("inf")

    with open(path, "r") as f:
        for line in f:
            try:
                record = json.loads(line)
                if record.get("symbol") != symbol:
                    continue
                ts = int(record.get("timestamp", 0))
                diff = abs(ts - now_ts)
                if diff <= 600_000 and diff < best_diff:
                    best = record
                    best_diff = diff
            except Exception:
                continue

    return best["score"] if best else None

# === Fallback â€” Recalculate Using Full Fork Logic ===
def compute_fork_score(symbol: str) -> float | None:
    """Fallback: use the fork_score_filter subscores logic to recalculate."""
    try:
        score, _, _, _ = compute_subscores(symbol)
        return score
    except Exception as e:
        print(f"[ERROR] Could not compute score for {symbol}: {e}")
        return None
