import json
import time
import hmac
import hashlib
import requests
import pandas as pd
from pathlib import Path
from datetime import datetime
from ta.trend import MACD, ADXIndicator
from ta.momentum import RSIIndicator

# === Paths ===
CANDIDATE_PATH = Path("/home/signal/market6/output/final_fork_rrr_trades.json")
SNAPSHOT_BASE = Path("/home/signal/market6/data/snapshots")
RESULTS_BASE = Path("/home/signal/market6/live/logs")
FORK_HISTORY = Path("/home/signal/market6/output/fork_history")
CRED_PATH = Path("/home/signal/market6/config/paper_cred.json")

# === Registry paths ===
REGISTRY_PATH = RESULTS_BASE / "fork_registry.json"
BTC_LOG_PATH = Path("/home/signal/market6/live/btc_logs")

def compute_score_hash(indicators):
    keys = ["macd_histogram", "stoch_rsi_cross", "rsi_recovery", "adx_rising", "ema_price_reclaim"]
    return "_".join([f"{k}:{indicators.get(k, 0)}" for k in keys])

def get_day_folder(entry_time):
    day = datetime.utcfromtimestamp(entry_time).strftime("%Y-%m-%d")
    folder = RESULTS_BASE / day
    folder.mkdir(parents=True, exist_ok=True)
    return folder

def get_entry_price(symbol, entry_ts):
    date_str = datetime.utcfromtimestamp(entry_ts).strftime("%Y-%m-%d")
    base = symbol.replace("USDT", "") if symbol.endswith("USDT") else symbol
    filename = f"{base}_15m_klines.json"
    filepath = SNAPSHOT_BASE / date_str / filename

    if not filepath.exists():
        print(f"[WARN] Snapshot not found: {filepath}")
        return None

    with open(filepath, "r") as f:
        klines = json.load(f)

    fallback_price = None
    for kline in klines:
        candle_ts = kline[0] // 1000
        if candle_ts <= entry_ts:
            fallback_price = float(kline[4])
        else:
            break

    return fallback_price

def save_daily_entry(entry):
    folder = get_day_folder(entry["entry_time"])
    out_path = folder / "completed_forks.jsonl"
    with open(out_path, "a") as f:
        f.write(json.dumps(entry) + "\n")

def load_registry():
    if REGISTRY_PATH.exists():
        with open(REGISTRY_PATH, "r") as f:
            return json.load(f)
    return {}

def save_registry(registry):
    with open(REGISTRY_PATH, "w") as f:
        json.dump(registry, f, indent=2)

def get_live_3c_symbols():
    with open(CRED_PATH, "r") as f:
        creds = json.load(f)

    BOT_ID = creds["3commas_bot_id"]
    API_KEY = creds["3commas_api_key"]
    API_SECRET = creds["3commas_api_secret"]
    full_path = "/public/api/ver1/deals?scope=active"
    url = "https://api.3commas.io" + full_path
    signature = hmac.new(API_SECRET.encode(), full_path.encode(), hashlib.sha256).hexdigest()

    headers = {
        "Apikey": API_KEY,
        "Signature": signature
    }

    try:
        res = requests.get(url, headers=headers, timeout=10)
        res.raise_for_status()
        deals = res.json()

        symbols = set()
        for d in deals:
            if d.get("bot_id") == BOT_ID and d.get("status") == "bought":
                pair = d.get("pair", "")
                if pair.startswith("USDT_"):
                    symbols.add(pair.split("_")[1] + "USDT")
        return symbols

    except Exception as e:
        print(f"[ERROR] Failed to pull 3Commas trades: {e}")
        return set()

def get_live_3c_trades():
    with open(CRED_PATH, "r") as f:
        creds = json.load(f)

    BOT_ID = creds["3commas_bot_id"]
    API_KEY = creds["3commas_api_key"]
    API_SECRET = creds["3commas_api_secret"]
    path = "/public/api/ver1/deals?scope=active"
    url = "https://api.3commas.io" + path
    signature = hmac.new(API_SECRET.encode(), path.encode(), hashlib.sha256).hexdigest()

    headers = {
        "Apikey": API_KEY,
        "Signature": signature
    }

    try:
        res = requests.get(url, headers=headers, timeout=10)
        res.raise_for_status()
        return [d for d in res.json() if d.get("bot_id") == BOT_ID]
    except Exception as e:
        print(f"[ERROR] Failed to fetch 3Commas trades: {e}")
        return []

def send_dca_signal(symbol, volume=15):
    with open(CRED_PATH, "r") as f:
        creds = json.load(f)

    payload = {
        "bot_id": creds["3commas_bot_id"],
        "email_token": creds.get("3commas_email_token"),
        "pair": symbol,
        "quantity": volume
    }

    query = "/public/api/ver1/bots_deal_add_funds_request"
    url = "https://api.3commas.io" + query
    body = json.dumps(payload)

    timestamp = str(int(time.time()))
    signature_payload = f"{timestamp}{body}".encode()
    signature = hmac.new(
        creds["3commas_api_secret"].encode(),
        msg=signature_payload,
        digestmod=hashlib.sha256
    ).hexdigest()

    headers = {
        "APIKEY": creds["3commas_api_key"],
        "Signature": signature,
        "Timestamp": timestamp,
        "Content-Type": "application/json"
    }

    try:
        res = requests.post(url, headers=headers, data=body)
        res.raise_for_status()
        print(f"âœ… DCA signal sent for {symbol} | Volume: {volume} USDT")
    except Exception as e:
        print(f"[ERROR] Failed to send DCA signal for {symbol}: {e}")

def get_latest_indicators(symbol, tf="15m"):
    path = SNAPSHOT_BASE / datetime.utcnow().strftime("%Y-%m-%d") / f"{symbol}_{tf}_klines.json"
    if not path.exists():
        print(f"[WARN] Missing snapshot for {symbol}")
        return {}

    try:
        with open(path) as f:
            raw = json.load(f)
        if len(raw) < 50:
            print(f"[WARN] Not enough candles to compute indicators for {symbol}")
            return {}

        df = pd.DataFrame(raw, columns=[
            "timestamp", "open", "high", "low", "close", "volume",
            "close_time", "quote_asset_volume", "num_trades",
            "taker_base_volume", "taker_quote_volume", "ignore"
        ])
        df = df.astype({
            "open": float, "high": float, "low": float,
            "close": float, "volume": float
        })

        rsi_val = RSIIndicator(df["close"]).rsi().iloc[-1]
        macd_val = MACD(df["close"]).macd_diff().iloc[-1]
        adx_val = ADXIndicator(df["high"], df["low"], df["close"]).adx().iloc[-1]

        return {
            "rsi": round(float(rsi_val), 2),
            "macd_histogram": round(float(macd_val), 5),
            "adx": round(float(adx_val), 2)
        }

    except Exception as e:
        print(f"[ERROR] Could not compute indicators for {symbol}: {e}")
        return {}

def load_fork_entry_score(symbol):
    try:
        for folder in sorted(FORK_HISTORY.glob("*"), reverse=True):
            path = folder / "fork_scores.jsonl"
            if not path.exists():
                continue
            with open(path) as f:
                for line in f:
                    obj = json.loads(line)
                    if obj.get("symbol") == symbol:
                        return obj.get("score", None)
    except Exception as e:
        print(f"[ERROR] Failed to load fork entry score for {symbol}: {e}")
    return None

def simulate_new_avg_price(current_avg, added_usdt, current_price):
    try:
        tokens = added_usdt / current_price
        new_total_usdt = current_avg * tokens + added_usdt
        new_total_tokens = tokens * 2
        return new_total_usdt / new_total_tokens
    except Exception as e:
        print(f"[ERROR] Failed to simulate BE price: {e}")
        return current_avg

def recompute_fork_score(symbol):
    indicators = get_latest_indicators(symbol)
    if not indicators:
        return 0.0
    score = 0.0
    score += 1.0 if indicators.get("macd_histogram", -1) > 0 else 0
    score += 1.0 if indicators.get("rsi", 0) > 45 else 0
    score += 1.0 if indicators.get("adx", 0) > 20 else 0
    return round(score / 3, 3)

def load_btc_market_condition():
    try:
        today = datetime.utcnow().strftime("%Y-%m-%d")
        path = BTC_LOG_PATH / today / "btc_snapshots.jsonl"
        if not path.exists():
            return None
        with open(path) as f:
            lines = f.readlines()
        latest = json.loads(lines[-1])
        return latest.get("market_condition")  # or rsi/macd/vwap if needed
    except Exception as e:
        print(f"[WARN] Failed to load BTC condition: {e}")
        return None
