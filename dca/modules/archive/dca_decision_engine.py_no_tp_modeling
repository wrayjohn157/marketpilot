# dca_decision_engine.py

def should_dca(trade_data):
    """
    Decide whether to trigger a DCA for a given trade.
    Returns (bool, rejection_reason)
    """
    drawdown = trade_data.get("deviation_pct", 0)
    score = trade_data.get("current_score", 0)
    entry_score = trade_data.get("entry_score", 0)
    safu_score = trade_data.get("safu_score", 0)
    health_check = trade_data.get("health_check", True)
    tp1_shift = trade_data.get("simulated_tp1_pct", 0)
    btc_status = trade_data.get("btc_status", "UNKNOWN")

    # === Smart Rejection Rules ===
    if btc_status != "SAFE":
        return False, "btc_unsafe"

    if score is not None and score < 0.3:
        return False, "score_decay"

    if not health_check:
        return False, "indicators"

    if safu_score < 0.4:
        return False, "safu_score"

    if tp1_shift > 5.0:
        return False, "tp1_unreachable"

    if drawdown < 2.5:
        return False, "drawdown_too_shallow"

    return True, "ok"


def how_much_to_dca(trade_data, so_table):
    """
    Decide how much USDT to inject based on confidence and step.
    """
    current_so = trade_data.get("step", 0)
    if current_so >= len(so_table):
        return 0

    confidence_score = 0
    score = trade_data.get("current_score", 0)
    safu = trade_data.get("safu_score", 0)
    tp1_shift = trade_data.get("simulated_tp1_pct", 0)

    # Confidence scaling
    if score > 0.7:
        confidence_score += 1
    if safu > 0.6:
        confidence_score += 1
    if tp1_shift < 3:
        confidence_score += 1

    if confidence_score >= 2:
        return so_table[current_so]  # Full step
    else:
        return round(so_table[current_so] * 0.5, 2)  # Half-step cautiously
