#!/usr/bin/env python3

import os
import json
import argparse
from pathlib import Path
from datetime import datetime, timedelta
from dateutil import parser as dateparser

# === Config Root Paths ===
SCRUBBED_DIR = Path("/home/signal/market7/ml/datasets/scrubbed_paper")
FORK_DIR = Path("/home/signal/market7/output/fork_history")
TV_DIR = Path("/home/signal/market7/output/tv_history")
BTC_DIR = Path("/home/signal/market7/dashboard_backend/btc_logs")
OUTPUT_DIR = Path("/home/signal/market7/ml/merged")

# === Loaders ===
def load_jsonl(path):
    if not path.exists():
        return []
    with open(path) as f:
        return [json.loads(line.strip()) for line in f if line.strip()]

def save_jsonl(path, records):
    path.parent.mkdir(parents=True, exist_ok=True)
    with open(path, "w") as f:
        for rec in records:
            f.write(json.dumps(rec) + "\n")

# === Matchers ===
def find_fork(symbol, ts, forks):
    for fork in forks:
        if fork["symbol"] == symbol:
            fork_time = dateparser.parse(fork["ts_iso"])
            if abs((ts - fork_time).total_seconds()) <= 60:
                return fork
    return None

def find_tv(symbol, ts, tvs):
    for tv in tvs:
        if tv["symbol"] == symbol and tv.get("pass"):
            tv_time = dateparser.parse(tv["ts_iso"])
            if abs((ts - tv_time).total_seconds()) <= 30:
                return tv
    return None

def find_btc(ts, btc_snaps):
    closest = None
    min_delta = float("inf")
    for snap in btc_snaps:
        snap_time = dateparser.parse(snap["ts_iso"])
        delta = abs((snap_time - ts).total_seconds())
        if delta < min_delta:
            closest = snap
            min_delta = delta
    return closest

# === Main Logic ===
def run_hail_mary(date_str):
    scrubbed_path = SCRUBBED_DIR / date_str / "scrubbed_trades.jsonl"
    fork_path = FORK_DIR / date_str / "fork_scores.jsonl"
    tv_path = TV_DIR / date_str / "tv_kicker.jsonl"
    btc_path = BTC_DIR / date_str / "btc_snapshots.jsonl"
    output_path = OUTPUT_DIR / f"merged_trades_{date_str}.jsonl"

    print(f"ðŸ©º Attempting Hail Mary rescue for: {scrubbed_path}")

    trades = load_jsonl(scrubbed_path)
    forks = load_jsonl(fork_path)
    tvs = load_jsonl(tv_path)
    btc = load_jsonl(btc_path)

    enriched = []

    for trade in trades:
        symbol = trade["symbol"].replace("USDT", "")
        entry_ts = dateparser.parse(trade["entry_time"])
        exit_ts = dateparser.parse(trade["exit_time"])

        fork_match = find_fork(symbol, entry_ts, forks)
        tv_match = find_tv(symbol, entry_ts, tvs)

        if not fork_match and tv_match:
            fork_match = find_fork(symbol, dateparser.parse(tv_match["ts_iso"]), forks)

        btc_entry = find_btc(entry_ts, btc)
        btc_exit = find_btc(exit_ts, btc)

        record = {
            "trade": trade,
            "fork": fork_match,
            "tv_kicker": tv_match,
            "btc_context": {
                "entry": btc_entry,
                "exit": btc_exit
            }
        }

        if tv_match and not fork_match:
            record["tv_screener_kick_applied"] = True

        enriched.append(record)

    save_jsonl(output_path, enriched)
    print(f"âœ… Merged result written to {output_path}")

# === CLI Entry ===
if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--date", required=True, help="Date to process, e.g. 2025-05-12")
    args = parser.parse_args()
    run_hail_mary(args.date)
