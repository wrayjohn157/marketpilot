#!/usr/bin/env python3
import json
import argparse
from datetime import datetime, timezone
from pathlib import Path

# === BASES (project-relative)
PROJECT_ROOT = Path(__file__).resolve().parents[2]
PAPER_BASE   = PROJECT_ROOT / "ml/datasets/scrubbed_paper"
FORK_BASE    = PROJECT_ROOT / "output/fork_history"
TV_BASE      = PROJECT_ROOT / "output/tv_history"
BTC_BASE     = PROJECT_ROOT / "dashboard_backend/btc_logs"
OUT_BASE     = PROJECT_ROOT / "ml/datasets/enriched"

# === Tolerances
FORK_GRACE_S = 1800
BTC_GRACE_S  = 3600

def parse_iso(z): return datetime.strptime(z, "%Y-%m-%dT%H:%M:%SZ").replace(tzinfo=timezone.utc)
def normalize(sym): return sym.upper().strip().replace("USDT", "")
def load_jsonl(p): return [json.loads(l) for l in open(p) if l.strip()] if p.exists() else []

def close_enough(ts_ms, target_dt, grace_s):
    try:
        dt = datetime.fromtimestamp(int(ts_ms)/1000, tz=timezone.utc)
        return abs((dt - target_dt).total_seconds()) <= grace_s
    except:
        return False

def find_closest(records, symbol, entry_dt, grace_s, use_ts="timestamp"):
    best, bd = None, float('inf')
    for r in records:
        if normalize(r.get("symbol", "")) != normalize(symbol): continue
        try:
            dt = datetime.fromtimestamp(int(r[use_ts])/1000, tz=timezone.utc)
            diff = abs((dt - entry_dt).total_seconds())
            if diff < bd and diff <= grace_s:
                best, bd = r, diff
        except:
            continue
    return best

def find_btc_snap(snapshots, dt):
    best, bd = None, float('inf')
    for s in snapshots:
        try:
            snap_dt = datetime.fromisoformat(s["ts_iso"].replace("Z", "+00:00"))
            diff = abs((snap_dt - dt).total_seconds())
            if diff < bd and diff <= BTC_GRACE_S:
                best, bd = s, diff
        except:
            continue
    return best

def enrich(date_str):
    paper_path = PAPER_BASE / date_str / "scrubbed_trades.jsonl"
    fork_path  = FORK_BASE  / date_str / "fork_scores.jsonl"
    tv_path    = TV_BASE    / date_str / "tv_kicker.jsonl"
    btc_path   = BTC_BASE   / date_str / "btc_snapshots.jsonl"
    out_path   = OUT_BASE   / date_str
    out_path.mkdir(parents=True, exist_ok=True)

    trades = load_jsonl(paper_path)
    forks  = load_jsonl(fork_path)
    tvs    = load_jsonl(tv_path)
    btc    = load_jsonl(btc_path)

    enriched, unmatched = [], []

    for t in trades:
        symbol = t["symbol"]
        try:
            e_dt = parse_iso(t["entry_time"])
            x_dt = parse_iso(t["exit_time"])
        except:
            unmatched.append({**t, "reason": "bad_timestamp"})
            continue

        fork = find_closest(forks, symbol, e_dt, FORK_GRACE_S)

        # fallback to TV boost
        if not fork or not fork.get("passed"):
            tv = find_closest(tvs, symbol, e_dt, FORK_GRACE_S)
            if tv:
                base_fork = find_closest(forks, symbol, e_dt, FORK_GRACE_S)
                if base_fork:
                    fork = dict(base_fork)
                    fork.update({
                        "tv_kicker_applied": True,
                        "tv_tag": tv.get("tv_tag"),
                        "tv_kicker": tv.get("tv_kicker"),
                        "adjusted_score": tv.get("adjusted_score"),
                        "tv_ts": tv.get("timestamp"),
                        "tv_ts_iso": tv.get("ts_iso")
                    })

        if not fork:
            unmatched.append({**t, "reason": "no_fork_found"})
            continue

        enriched.append({
            **t,
            "deal_id": t["trade_id"],
            "fork_score": fork,
            "btc_entry": find_btc_snap(btc, e_dt),
            "btc_exit":  find_btc_snap(btc, x_dt),
            "duration_min": round(abs((x_dt - e_dt).total_seconds()) / 60, 2)
        })

    with open(out_path / "enriched_data.jsonl", "w") as f:
        for r in enriched: f.write(json.dumps(r) + "\n")

    with open(out_path / "unmatched_trades.jsonl", "w") as f:
        for r in unmatched: f.write(json.dumps(r) + "\n")

    print(f"[✅ DONE] Enriched: {len(enriched)} | Unmatched: {len(unmatched)} → {out_path}")

# === CLI ===
if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--date", required=True, help="Target date (YYYY-MM-DD)")
    args = parser.parse_args()
    enrich(args.date)
